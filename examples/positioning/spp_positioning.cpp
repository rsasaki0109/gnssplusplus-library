#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
#include <libgnss++/algorithms/spp.hpp>
#include <libgnss++/core/types.hpp>
#include <libgnss++/io/rinex.hpp>

using namespace libgnss;

struct PositioningConfig {
    std::string obs_file;
    std::string nav_file;
    std::string output_file = "spp_results.pos";
    bool enable_rtk = false;
    double snr_mask = 30.0;
    double elevation_mask = 5.0; // degrees
    int max_epochs = -1; // -1 = all epochs
    bool verbose = false;
};

void print_usage(const char* program_name) {
    std::cout << "Usage: " << program_name << " [options]\n"
              << "Options:\n"
              << "  -obs <file>     RINEX observation file\n"
              << "  -nav <file>     RINEX navigation file\n"
              << "  -o <file>       Output POS file (default: spp_results.pos)\n"
              << "  --rtk           Enable RTK processing (default: SPP only)\n"
              << "  --snr <value>   SNR mask in dB (default: 30.0)\n"
              << "  --elev <value>  Elevation mask in degrees (default: 5.0)\n"
              << "  --max-epochs <n> Maximum epochs to process (default: all)\n"
              << "  --verbose       Verbose output\n"
              << "  -h, --help      Show this help\n";
}

PositioningConfig parse_arguments(int argc, char* argv[]) {
    PositioningConfig config;
    
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        
        if (arg == "-h" || arg == "--help") {
            print_usage(argv[0]);
            exit(0);
        } else if (arg == "-obs" && i + 1 < argc) {
            config.obs_file = argv[++i];
        } else if (arg == "-nav" && i + 1 < argc) {
            config.nav_file = argv[++i];
        } else if (arg == "-o" && i + 1 < argc) {
            config.output_file = argv[++i];
        } else if (arg == "--rtk") {
            config.enable_rtk = true;
        } else if (arg == "--snr" && i + 1 < argc) {
            config.snr_mask = std::stod(argv[++i]);
        } else if (arg == "--elev" && i + 1 < argc) {
            config.elevation_mask = std::stod(argv[++i]);
        } else if (arg == "--max-epochs" && i + 1 < argc) {
            config.max_epochs = std::stoi(argv[++i]);
        } else if (arg == "--verbose") {
            config.verbose = true;
        } else {
            std::cerr << "Unknown argument: " << arg << std::endl;
            print_usage(argv[0]);
            exit(1);
        }
    }
    
    if (config.obs_file.empty() || config.nav_file.empty()) {
        std::cerr << "Error: Both observation and navigation files are required" << std::endl;
        print_usage(argv[0]);
        exit(1);
    }
    
    return config;
}

void write_pos_header(std::ofstream& file, bool rtk_enabled) {
    file << "% POS file generated by LibGNSS++ SPP" << (rtk_enabled ? "/RTK" : "") << " Processor\n";
    file << "% Format: GPST latitude(deg) longitude(deg) height(m) Q ns sdn sde sdu sdne sdeu sdun age ratio\n";
    file << "%\n";
    file << "% Q: 1=FIXED, 2=FLOAT, 4=DGPS, 5=SPP\n";
    file << "% ns: number of satellites\n";
    file << "% sdn,sde,sdu: standard deviation (m)\n";
    file << "% sdne,sdeu,sdun: correlation\n";
    file << "% age: age of differential (s)\n";
    file << "% ratio: ambiguity ratio\n";
    file << "%\n";
}

void write_solution(std::ofstream& file, const PositionSolution& solution) {
    if (!solution.isValid()) return;
    
    // Convert ECEF to geodetic
    auto geodetic = spp_utils::ecefToGeodetic(solution.position_ecef);
    
    // Convert time to GPS week/TOW
    int week = solution.time.week;
    double tow = solution.time.tow;
    
    // Quality mapping
    int quality = 5; // Default to SPP
    switch (solution.status) {
        case SolutionStatus::FIXED: quality = 1; break;
        case SolutionStatus::FLOAT: quality = 2; break;
        case SolutionStatus::DGPS: quality = 4; break;
        case SolutionStatus::SPP: quality = 5; break;
        default: quality = 0; break;
    }
    
    file << std::fixed << std::setprecision(3);
    file << week << " " << tow << " ";
    file << std::setprecision(9);
    file << geodetic.latitude * 180.0 / M_PI << " ";
    file << geodetic.longitude * 180.0 / M_PI << " ";
    file << std::setprecision(4);
    file << geodetic.height << " ";
    file << quality << " " << solution.num_satellites << " ";
    file << std::setprecision(4);
    file << "0.1000 "; // Default std dev for SPP
    file << "0.1000 "; 
    file << "0.2000 "; // Vertical typically worse
    file << "0.0000 0.0000 0.0000 "; // Correlations (not computed)
    file << "0.0 "; // Age
    file << "0.0"; // Ratio
    file << std::endl;
}

int main(int argc, char* argv[]) {
    try {
        PositioningConfig config = parse_arguments(argc, argv);
        
        std::cout << "LibGNSS++ " << (config.enable_rtk ? "RTK" : "SPP") << " Positioning\n";
        std::cout << "============================================\n";
        std::cout << "Observation file: " << config.obs_file << "\n";
        std::cout << "Navigation file:  " << config.nav_file << "\n";
        std::cout << "Output file:      " << config.output_file << "\n";
        std::cout << "Processing mode:  " << (config.enable_rtk ? "RTK" : "SPP only") << "\n";
        std::cout << "SNR mask:         " << config.snr_mask << " dB\n";
        std::cout << "Elevation mask:   " << config.elevation_mask << " degrees\n";
        std::cout << "============================================\n\n";
        
        // Initialize RINEX reader
        io::RINEXReader rinex_reader;
        
        // Load navigation data
        std::cout << "Loading navigation data..." << std::endl;
        NavigationData nav_data;
        if (!rinex_reader.open(config.nav_file) || !rinex_reader.readNavigationData(nav_data)) {
            std::cerr << "Error: Failed to read navigation file" << std::endl;
            return 1;
        }
        rinex_reader.close();
        std::cout << "Loaded navigation data successfully" << std::endl;
        
        // Initialize SPP processor
        SPPProcessor spp_processor;
        ProcessorConfig proc_config;
        proc_config.snr_mask = config.snr_mask;
        proc_config.elevation_mask = config.elevation_mask * M_PI / 180.0; // Convert to radians
        
        if (!spp_processor.initialize(proc_config)) {
            std::cerr << "Error: Failed to initialize SPP processor" << std::endl;
            return 1;
        }
        
        // Open output file
        std::ofstream output_file(config.output_file);
        if (!output_file.is_open()) {
            std::cerr << "Error: Cannot open output file: " << config.output_file << std::endl;
            return 1;
        }
        
        write_pos_header(output_file, config.enable_rtk);
        
        // Process observation data
        std::cout << "Processing observations..." << std::endl;
        
        if (!rinex_reader.open(config.obs_file)) {
            std::cerr << "Error: Failed to open observation file" << std::endl;
            return 1;
        }
        
        int processed_epochs = 0;
        int valid_solutions = 0;
        auto start_time = std::chrono::high_resolution_clock::now();
        
        ObservationData obs_data;
        while (rinex_reader.readObservationEpoch(obs_data)) {
            if (config.max_epochs > 0 && processed_epochs >= config.max_epochs) {
                break;
            }
            
            // Process with SPP
            auto solution = spp_processor.processEpoch(obs_data, nav_data);
            
            if (solution.isValid()) {
                write_solution(output_file, solution);
                valid_solutions++;
                
                if (config.verbose) {
                    auto geodetic = spp_utils::ecefToGeodetic(solution.position_ecef);
                    std::cout << "Epoch " << processed_epochs + 1 
                              << ": Lat=" << std::fixed << std::setprecision(6) 
                              << geodetic.latitude * 180.0 / M_PI
                              << " Lon=" << geodetic.longitude * 180.0 / M_PI
                              << " Height=" << std::setprecision(2) << geodetic.height
                              << " Sats=" << solution.num_satellites
                              << " Quality=" << static_cast<int>(solution.status) << std::endl;
                }
            }
            
            processed_epochs++;
            
            if (processed_epochs % 100 == 0) {
                std::cout << "Processed " << processed_epochs << " epochs, "
                          << valid_solutions << " valid solutions ("
                          << std::fixed << std::setprecision(1)
                          << 100.0 * valid_solutions / processed_epochs << "%)" << std::endl;
            }
        }
        
        rinex_reader.close();
        
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        
        output_file.close();
        
        // Print statistics
        std::cout << "\n============================================\n";
        std::cout << "Processing completed!\n";
        std::cout << "Total epochs processed: " << processed_epochs << "\n";
        std::cout << "Valid solutions:        " << valid_solutions << "\n";
        std::cout << "Success rate:           " << std::fixed << std::setprecision(1)
                  << 100.0 * valid_solutions / processed_epochs << "%\n";
        std::cout << "Processing time:        " << duration.count() << " ms\n";
        std::cout << "Average time per epoch: " << std::fixed << std::setprecision(2)
                  << (double)duration.count() / processed_epochs << " ms\n";
        std::cout << "Output saved to:        " << config.output_file << "\n";
        std::cout << "============================================\n";
        
        // Get processor statistics
        auto spp_stats = spp_processor.getStats();
        std::cout << "\nSPP Processor Statistics:\n";
        std::cout << "Total epochs:           " << spp_stats.total_epochs << "\n";
        std::cout << "Valid solutions:        " << spp_stats.valid_solutions << "\n";
        std::cout << "Average processing time: " << std::fixed << std::setprecision(2)
                  << spp_stats.average_processing_time_ms << " ms\n";
        
        return 0;
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "Unknown error occurred" << std::endl;
        return 1;
    }
}
